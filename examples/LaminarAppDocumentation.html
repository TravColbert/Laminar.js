<!DOCTYPE html>
<html lang="en">
<head>
  <title>Laminar Examples</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="stylesheet" href="css/laminar_doc.css">
  <link rel="stylesheet" href="../../Laminar.Layouts/laminar-base.css">
  <style>
    .todocomplete {
      text-decoration: line-through
    }
    .editable .tododescription,
    .editable .todocomplete,
    .editable .tododelete 
    {
      display: none;
    }
    .editable .todoinput {
      display: visible;
    }
    .editable .tododescription,
    .editable .todocomplete,
    .editable .tododelete 
    {
      display: visible;
    }
    .noteditable .todoinput {
      display: none;
    }

  </style>
</head>
<body class="layout-col">
<script src="../laminar.js"></script>
<script src="../laminar.model.js"></script>
<div id="laminarapptodolistdiv" class="layout-col">
  <div id="todolistdiv" class="layout-row"></div>
</div>
<div id="todolistadddiv" class="layout-row"></div>
<div id="todolistcontrolsdiv" class="layout-row"></div>
<script>
  // First, we build the model
  var todoListHandlerFunctions = {};    // This is an object that allows us to
                                        // add triggers for events on the model

  // The todo list will just be an array of all the todos
  var todosArr = new Laminar.createModel([],todoListHandlerFunctions);   // Each todo will be an element in the todos array
  /* We passed an empty 'todoListHandlerFunctions' object to the createModel()
   * method. This method has created a Javascript PROXY object that has wrapped
   * the empty array ([]).
   * Also, the 'todoListHandlerFunctions' has now been given a few extra powers.
   * We can now add new proxy handler functions to it by using its .addHandler()
   * method.
   * We'll use it a little later.
   *
   * Let's build the mechanism that will properly store a todo when one is
   * submitted. We'll use array's normal PUSH() method to add todos. But we
   * need to add some ability to properly store a unique ID and completed
   * state of each todo.
   * This is why we use a Javascript PROXY object to wrap around our simple array.
   * Our PROXY object will intercept PUSH() calls and other methods used on the
   * array and we can insert our own functions in the process.
   *
   * The individual todos will by objects looking like this:
   *
  var todo = {
    description:"This is the first todo",
    completed:false
  };
   *
   * So, our handler will get a string (description) and it will convert it to an
   * object as described above.
   *
   * All 'SET'-type handlers must accept arguments of:
   *   TARGET - the target object
   *   PROPERTY - the property name
   *   VALUE - the desired value of the property
   */
  var addTodoItem = function(target,property,value) {
    console.log("== In the addTodoItem method.\n== This is going to want to create and return a new Laminar model.\n== This is property",property,"with value",value);
    if(Array.isArray(target)) console.log("Length of array is",target.length);
    /* Let's just check to make sure this is not a SET to the length property
     * of the array itself. Unfortunately ANY and ALL types of access get
     * caught by these PROXY handler events.
     */
    if(Array.isArray(target) && property=="length") {
      // Just pass on the value as if nothing happened.
      return value;
    }
    if(typeof value === "object") {
      console.log("This is probably an object. Not continueing addTodoItem function");
      return value;
    }
    /*
    var todoItem = new Laminar.createModel(
      {
        description:value,
        completed:false
      }
    );
    */
    todoItem = {
      description:value,
      completed:false
    };
    return todoItem;
  };

  /* So, now we have a function called addTodoItem that we need to insert into
   * the PROXY's SET method.
   * We do this by inserting this function in that empty 'todoListHandlerFunctions'
   * object we created earlier. As we add methods to it, they get accessible by
   * all PROXY objects that are created with it.
   *
   * So, let's add the addTodoItem as a SET method.
   */
  todoListHandlerFunctions.addHandler("set",addTodoItem);

  /* Now, we have a little function that will always trigger when we do
   * something like:
   *
   *   todosArr.push("This is my first todo.");
   *
   * Our little handler function will, instead, turn that descripton into a full
   * object and insert the object into the todosArr array.
   *
   * Now, let's build the views that will be attached to the model
   */
  var todoList = new Laminar.Widget({
    id:"todolist",
    classlist:["layout-col"],
    parent:"#todolistdiv"
  });

  // An ADD control:
  var todoListAddDescription = new Laminar.Widget({
    id:"todolistadddescription",
    element:"input",
    type:"textinput",
    parent:"#todolistadddiv"
  });

  /* As for that todoList Laminar.Widget, let's teach it how to build a list of
   * todo items...
   */
  todoList.buildItemList = function(list) {
    todoList.empty();
    if(list.length>0) {
      for(var c=0;c<list.length;c++) {
        this.buildItem(list[c],c);
      }
      return;
    }
    this.content("This is an empty todo list");
  };

  todoList.buildItem = function(item,number) {
    console.log("Item",number,item.description);
    // The DIV to hold the todo item
    var itemDiv = new Laminar.Widget({
      id:"tododiv_" + number,
      classlist:["layout-row"],
      statelist:["noteditable","editable"],
      parent:todoList
    });
    // The todo description
    var itemDescr = new Laminar.Widget({
      id:"tododescr_" + number,
      content:item.description,
      classlist:(item.completed) ? ["todocomplete","tododescription"] : ["tododescription"],
      parent:itemDiv
    });
    // A way to edit the todo...
    var itemInput = new Laminar.Widget({
      id:"todoinput_" + number,
      element:"input",
      type:"textinput",
      classlist:["todoinput"],
      value:item.description,
      parent:itemDiv
    });
    // The todo completed flag
    var itemComplete = new Laminar.Widget({
      id:"todocomplete_" + number,
      element:"input",
      type:"checkbox",
      proplist:(item.completed) ? [["checked","true"]] : null,
      classlist:["todocomplete"],
      parent:itemDiv
    });
    // The todo delete button
    var itemDelete = new Laminar.Widget({
      id:"tododelete_" + number,
      element:"input",
      type:"button",
      classlist:["tododelete"],
      parent:itemDiv
    });
    /* When you double-click the description let's edit the todo
     */
    itemDescr.listenEvent("dblclick",function(e,obj) {
      console.log("Editing todo element",obj.html());
      itemDiv.setState("editable");
    });
    /* When you change the todoinput we have to tell the model that the todo
     * item's description has changed.
     */
    itemInput.listenEvent("change",function(e,obj) {
      item.description = obj.value();
      /* For this iteration we tell the whole todo list model that there has
       * been an update. The todo list will fetch the change and update the
       * whole list
       */
      todoList.fetchTodos();
    });
    itemInput.listenEvent("blur",function(e,obj) {
      item.description = obj.value();
      /* For this iteration we tell the whole todo list model that there has
       * been an update. The todo list will fetch the change and update the
       * whole list
       */
      todoList.fetchTodos();
    });
    /* When you click the complete checkbox the item has to tell the model that
     * the todo item has been completed.
     */
    itemComplete.listenEvent("change",function(e,obj) {
      item.completed = (obj.domElement.checked);
      /* For this iteration we tell the whole todo list model that there has
       * been an update. The todo list will fetch the change and update the
       * whole list
       */
      todoList.fetchTodos();
    });
    /* When you click the delete button we need to delete the item
     */
    itemDelete.listenEvent("click",function(e,obj) {
      console.log("Splicing out",number,"from todosArr array");
      console.log("Delete result:",(todosArr.splice(number,1)));
      todoList.fetchTodos();
    });
  };

  todoList.fetchTodos = function() {
    console.log("todoList is fetching todos from todosArr");
    this.buildItemList(todosArr);
  }

  /*
   * Now, we need to make something that works the other way and updates our UI
   * when we add a todo.
   *
   * Let's create another handler that reacts AFTER the set has been performed.
   */
  var changeTodoList = function(list,property) {
    /* Remember!: array length properties change!
     * In this case we don't want to work off of that information,
     * although it is very useful elsewhere!
     * So, let's ignore it as this step.
     */
    if(Array.isArray(list) && property=="length") return;
    /* Let's make the change cause the todoList Laminar Widget to rebuild the
     * todo items
     */
    console.log("Alert! It looks like item #",property,"changed!");
    console.log("List is currently:",list.length);
    todoList.buildItemList(list);
  }

  /* Add it to our todoListHandlerFunctions object:
   */
  todoListHandlerFunctions.addHandler("change",changeTodoList);


  /* While we're here let's connect this add control with our model
   */
  todoListAddDescription.listenEvent("change",function(e,obj){
    console.log("Add description value: " + obj.value());
    // Push the new ToDo into the todosArr
    todosArr.push(obj.value());
    /* Lastly, let's make this widget clear itself */
    todoList.fetchTodos();
    obj.empty();
  });

  todoList.fetchTodos();

</script>
</body>
</html>